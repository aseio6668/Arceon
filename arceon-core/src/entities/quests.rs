use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Dynamic quest system with NPC-driven needs and evolving requirements
/// Quests are generated by NPCs based on their changing needs and world state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuestSystem {
    pub active_quests: HashMap<Uuid, Quest>,
    pub completed_quests: Vec<CompletedQuest>,
    pub available_quests: HashMap<Uuid, Quest>, // Quests offered by NPCs
    pub faction_reputations: HashMap<String, FactionReputation>,
    pub global_events: Vec<GlobalEvent>, // World events that create quests
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Quest {
    pub id: Uuid,
    pub title: String,
    pub description: String,
    pub quest_type: QuestType,
    pub giver_npc_id: Uuid,
    pub giver_faction: Option<String>,
    pub objectives: Vec<QuestObjective>,
    pub rewards: Vec<QuestReward>,
    pub requirements: Vec<QuestRequirement>,
    pub time_limit: Option<DateTime<Utc>>,
    pub priority: QuestPriority,
    pub reputation_changes: Vec<ReputationChange>,
    pub generated_by_need: Option<NpcNeed>,
    pub created_at: DateTime<Utc>,
    pub can_fail: bool,
    pub failure_consequences: Vec<QuestConsequence>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuestType {
    // Resource gathering
    Gather(String, u32),           // item_name, quantity
    Hunt(String, u32),             // creature_type, quantity
    Craft(String, u32),            // item_name, quantity
    
    // Delivery and transport
    Delivery(String, Uuid),        // item_name, destination_npc_id
    Transport(Uuid, String),       // npc_id, destination_area
    
    // Combat and protection
    Kill(String, u32),             // target_type, quantity
    Escort(Uuid, String),          // npc_id, destination
    Defend(String, DateTime<Utc>), // location, until_time
    
    // Exploration and discovery
    Explore(String),               // area_name
    Discover(String),              // discovery_type (ruins, resources, etc.)
    Map(String),                   // area_name to map
    
    // Social and diplomatic
    Negotiate(Uuid, String),       // target_npc_id, goal
    Mediate(Uuid, Uuid),          // faction1_id, faction2_id
    Convince(Uuid, String),        // target_npc_id, goal
    
    // Construction and improvement
    Build(String, String),         // structure_type, location
    Repair(String, String),        // item_type, location
    Improve(String, u32),          // area_name, improvement_level
    
    // Knowledge and skill
    Teach(Uuid, String),           // student_npc_id, skill_name
    Learn(String, f64),            // skill_name, target_level
    Research(String),              // research_topic
    
    // Special event quests
    Emergency(EmergencyType),      // Crisis response
    Seasonal(SeasonalType),        // Time-limited events
    Chain(Vec<QuestType>),         // Multi-part quest chain
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EmergencyType {
    NaturalDisaster(String),       // disaster_type
    MonsterInvasion(String),       // monster_type
    ResourceShortage(String),      // resource_type
    PoliticalCrisis(String),       // crisis_description
    Plague(String),                // disease_type
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SeasonalType {
    Harvest(String),               // crop_type
    Festival(String),              // festival_name
    Migration(String),             // creature_type
    Trading(String),               // special_goods
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuestObjective {
    pub id: Uuid,
    pub description: String,
    pub objective_type: ObjectiveType,
    pub progress: u32,
    pub target: u32,
    pub is_completed: bool,
    pub is_optional: bool,
    pub rewards_on_completion: Vec<QuestReward>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ObjectiveType {
    CollectItems(String),          // item_name
    KillEnemies(String),          // enemy_type
    VisitLocation(String),        // location_name
    TalkToNpc(Uuid),              // npc_id
    UseSkill(String, u32),        // skill_name, times
    WaitTime(DateTime<Utc>),      // wait_until
    MeetCondition(String),        // condition_description
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuestReward {
    // Skill progression rewards
    SkillExperience(String, f64), // skill_name, amount
    SkillUnlock(String),          // skill_name
    
    // Reputation rewards
    FactionReputation(String, i32), // faction_name, amount
    NpcReputation(Uuid, i32),      // npc_id, amount
    
    // Knowledge and access rewards
    AreaAccess(String),            // area_name
    RecipeUnlock(String),          // recipe_name
    Information(String),           // lore or strategic info
    
    // Social rewards
    FactionMembership(String),     // faction_name
    Title(String),                 // honorary title
    Contact(Uuid),                 // new NPC contact
    
    // Material rewards (optional, since focus is on progression)
    Items(String, u32),            // item_name, quantity
    Resources(String, u32),        // resource_name, quantity
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuestRequirement {
    SkillLevel(String, f64),       // skill_name, min_level
    FactionReputation(String, i32), // faction_name, min_reputation
    CompletedQuest(Uuid),          // prerequisite_quest_id
    TimeWindow(DateTime<Utc>, DateTime<Utc>), // start_time, end_time
    AreaAccess(String),            // required_area_access
    NpcRelationship(Uuid, RelationshipLevel), // npc_id, min_relationship
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RelationshipLevel {
    Hostile = -100,
    Unfriendly = -50,
    Neutral = 0,
    Friendly = 50,
    Allied = 100,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuestPriority {
    Critical,    // World-changing events
    High,        // Urgent NPC needs
    Normal,      // Standard requests
    Low,         // Optional side tasks
    Background,  // Long-term goals
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuestConsequence {
    FactionReputationLoss(String, i32),
    NpcReputationLoss(Uuid, i32),
    AreaAccessLoss(String),
    ResourceScarcity(String),
    NpcDeath(Uuid),
    AreaDamage(String, u32),
    FactionConflict(String, String),
}

/// NPC needs that generate quests dynamically
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NpcNeed {
    pub npc_id: Uuid,
    pub need_type: NeedType,
    pub urgency: f32,              // 0.0 to 1.0
    pub expiry_time: DateTime<Utc>,
    pub context: String,           // Why this need exists
    pub affected_by_world_state: Vec<String>, // World factors that influence this need
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NeedType {
    // Basic survival needs
    Food(u32),                     // amount needed
    Water(u32),
    Shelter(String),               // shelter_type
    Safety(String),                // threat_type
    
    // Economic needs
    Trade(String, u32),            // resource_name, quantity
    Income(String),                // economic_activity
    Tools(String),                 // tool_type
    Materials(String, u32),        // material_type, quantity
    
    // Social needs
    Communication(Uuid),           // contact_npc_id
    Companionship(String),         // relationship_type
    Status(String),                // desired_social_position
    Knowledge(String),             // information_type
    
    // Professional needs
    Skills(String, f64),           // skill_name, target_level
    Equipment(String),             // equipment_type
    Workspace(String),             // workspace_type
    Contracts(String),             // work_type
    
    // Factional needs
    Loyalty(String),               // faction_name
    Influence(String, u32),        // area_name, target_influence
    Resources(String, u32),        // resource_type, quantity
    Allies(String),                // ally_type
}

/// Faction reputation system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FactionReputation {
    pub faction_name: String,
    pub reputation_value: i32,     // -1000 to +1000
    pub reputation_level: ReputationLevel,
    pub reputation_changes: Vec<ReputationRecord>,
    pub benefits: Vec<FactionBenefit>,
    pub penalties: Vec<FactionPenalty>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReputationLevel {
    Revered = 750,      // Highest honor
    Exalted = 500,      // Great respect
    Honored = 250,      // Well regarded
    Friendly = 100,     // Positive standing
    Neutral = 0,        // No opinion
    Unfriendly = -100,  // Negative standing
    Hostile = -250,     // Active dislike
    Hated = -500,       // Strong animosity
    Nemesis = -750,     // Absolute hatred
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationRecord {
    pub change_amount: i32,
    pub reason: String,
    pub timestamp: DateTime<Utc>,
    pub source_quest_id: Option<Uuid>,
    pub source_npc_id: Option<Uuid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationChange {
    pub faction_name: String,
    pub amount: i32,
    pub reason: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FactionBenefit {
    SkillTraining(String),         // skill_name available for training
    ExclusiveQuests,               // Access to faction-specific quests
    AreaAccess(String),            // area_name
    TradingBonus(f32),             // percentage bonus
    SkillExperienceBonus(String, f32), // skill_name, multiplier
    SpecialServices(String),       // service_description
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FactionPenalty {
    AreaRestriction(String),       // area_name
    TradingPenalty(f32),          // percentage penalty
    HostileNpcs(String),          // npc_type that becomes hostile
    QuestRestriction(String),      // quest_type unavailable
    SkillRestriction(String),      // skill_name training blocked
}

/// Global events that affect the world and create quests
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalEvent {
    pub id: Uuid,
    pub event_type: GlobalEventType,
    pub affected_areas: Vec<String>,
    pub duration: Option<chrono::Duration>,
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub consequences: Vec<String>,
    pub generated_quests: Vec<Uuid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GlobalEventType {
    War(String, String),           // faction1, faction2
    NaturalDisaster(String),       // disaster_type
    ResourceDiscovery(String),     // resource_type
    Migration(String),             // creature_type
    TechnologicalAdvancement(String), // advancement_type
    PoliticalChange(String),       // change_type
    EconomicShift(String),         // shift_type
    MagicalPhenomenon(String),     // phenomenon_type
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompletedQuest {
    pub quest_id: Uuid,
    pub completion_time: DateTime<Utc>,
    pub completion_quality: QuestCompletionQuality,
    pub rewards_earned: Vec<QuestReward>,
    pub reputation_changes: Vec<ReputationChange>,
    pub consequences: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuestCompletionQuality {
    Failed,
    Poor,
    Average,
    Good,
    Excellent,
    Perfect,
}

impl QuestSystem {
    pub fn new() -> Self {
        Self {
            active_quests: HashMap::new(),
            completed_quests: Vec::new(),
            available_quests: HashMap::new(),
            faction_reputations: HashMap::new(),
            global_events: Vec::new(),
        }
    }

    /// Generate quests based on NPC needs and world state
    pub fn generate_quests_from_needs(&mut self, npc_needs: Vec<NpcNeed>, world_state: &crate::state::GameState) {
        for need in npc_needs {
            let quest = self.create_quest_from_need(&need, world_state);
            if let Some(quest) = quest {
                self.available_quests.insert(quest.id, quest);
            }
        }
    }

    /// Create a quest from an NPC need
    fn create_quest_from_need(&self, need: &NpcNeed, world_state: &crate::state::GameState) -> Option<Quest> {
        // Get NPC information
        let npc_name = world_state.beings.get(&need.npc_id.to_string())?.name.clone();
        
        let (quest_type, title, description, rewards) = match &need.need_type {
            NeedType::Food(amount) => (
                QuestType::Gather("Food".to_string(), *amount),
                format!("{} needs food supplies", npc_name),
                format!("{} is running low on food and needs {} units to sustain themselves.", npc_name, amount),
                vec![
                    QuestReward::SkillExperience("Charisma".to_string(), 50.0),
                    QuestReward::NpcReputation(need.npc_id, 25),
                ]
            ),
            NeedType::Materials(material, amount) => (
                QuestType::Gather(material.clone(), *amount),
                format!("{} needs {} {}", npc_name, amount, material),
                format!("{} requires {} units of {} for their work.", npc_name, amount, material),
                vec![
                    QuestReward::SkillExperience("Gathering".to_string(), 75.0),
                    QuestReward::NpcReputation(need.npc_id, 20),
                ]
            ),
            NeedType::Safety(threat) => (
                QuestType::Kill(threat.clone(), 1),
                format!("Eliminate {} threatening {}", threat, npc_name),
                format!("{} is being threatened by {} and needs protection.", npc_name, threat),
                vec![
                    QuestReward::SkillExperience("Courage".to_string(), 100.0),
                    QuestReward::NpcReputation(need.npc_id, 50),
                ]
            ),
            NeedType::Knowledge(info_type) => (
                QuestType::Research(info_type.clone()),
                format!("Research {} for {}", info_type, npc_name),
                format!("{} seeks knowledge about {} to advance their understanding.", npc_name, info_type),
                vec![
                    QuestReward::SkillExperience("Intelligence".to_string(), 80.0),
                    QuestReward::Information(info_type.clone()),
                ]
            ),
            _ => return None, // Other need types can be implemented
        };

        let objectives = self.create_objectives_for_quest_type(&quest_type);
        
        Some(Quest {
            id: Uuid::new_v4(),
            title,
            description,
            quest_type,
            giver_npc_id: need.npc_id,
            giver_faction: None, // Could be determined from NPC's faction
            objectives,
            rewards,
            requirements: Vec::new(),
            time_limit: Some(need.expiry_time),
            priority: if need.urgency > 0.8 {
                QuestPriority::High
            } else if need.urgency > 0.5 {
                QuestPriority::Normal
            } else {
                QuestPriority::Low
            },
            reputation_changes: Vec::new(),
            generated_by_need: Some(need.clone()),
            created_at: Utc::now(),
            can_fail: true,
            failure_consequences: vec![
                QuestConsequence::NpcReputationLoss(need.npc_id, 10),
            ],
        })
    }

    /// Create objectives for a quest type
    fn create_objectives_for_quest_type(&self, quest_type: &QuestType) -> Vec<QuestObjective> {
        match quest_type {
            QuestType::Gather(item, amount) => vec![
                QuestObjective {
                    id: Uuid::new_v4(),
                    description: format!("Gather {} {}", amount, item),
                    objective_type: ObjectiveType::CollectItems(item.clone()),
                    progress: 0,
                    target: *amount,
                    is_completed: false,
                    is_optional: false,
                    rewards_on_completion: vec![
                        QuestReward::SkillExperience("Gathering".to_string(), 25.0),
                    ],
                }
            ],
            QuestType::Kill(target, amount) => vec![
                QuestObjective {
                    id: Uuid::new_v4(),
                    description: format!("Eliminate {} {}", amount, target),
                    objective_type: ObjectiveType::KillEnemies(target.clone()),
                    progress: 0,
                    target: *amount,
                    is_completed: false,
                    is_optional: false,
                    rewards_on_completion: vec![
                        QuestReward::SkillExperience("Courage".to_string(), 50.0),
                    ],
                }
            ],
            QuestType::Research(topic) => vec![
                QuestObjective {
                    id: Uuid::new_v4(),
                    description: format!("Research {}", topic),
                    objective_type: ObjectiveType::UseSkill("Intelligence".to_string(), 5),
                    progress: 0,
                    target: 5,
                    is_completed: false,
                    is_optional: false,
                    rewards_on_completion: vec![
                        QuestReward::Information(topic.clone()),
                    ],
                }
            ],
            _ => Vec::new(),
        }
    }

    /// Update faction reputation
    pub fn update_faction_reputation(&mut self, faction_name: &str, amount: i32, reason: &str, source_quest: Option<Uuid>) {
        let reputation = self.faction_reputations
            .entry(faction_name.to_string())
            .or_insert_with(|| FactionReputation {
                faction_name: faction_name.to_string(),
                reputation_value: 0,
                reputation_level: ReputationLevel::Neutral,
                reputation_changes: Vec::new(),
                benefits: Vec::new(),
                penalties: Vec::new(),
            });

        reputation.reputation_value += amount;
        reputation.reputation_value = reputation.reputation_value.clamp(-1000, 1000);
        
        // Update reputation level
        reputation.reputation_level = match reputation.reputation_value {
            750..=1000 => ReputationLevel::Revered,
            500..=749 => ReputationLevel::Exalted,
            250..=499 => ReputationLevel::Honored,
            100..=249 => ReputationLevel::Friendly,
            -99..=99 => ReputationLevel::Neutral,
            -249..=-100 => ReputationLevel::Unfriendly,
            -499..=-250 => ReputationLevel::Hostile,
            -749..=-500 => ReputationLevel::Hated,
            -1000..=-750 => ReputationLevel::Nemesis,
            _ => ReputationLevel::Neutral,
        };

        // Record the change
        reputation.reputation_changes.push(ReputationRecord {
            change_amount: amount,
            reason: reason.to_string(),
            timestamp: Utc::now(),
            source_quest_id: source_quest,
            source_npc_id: None,
        });

        // Update benefits and penalties based on new level
        let faction_name_copy = reputation.faction_name.clone();
        self.update_faction_benefits_and_penalties_by_name(&faction_name_copy);
    }

    /// Update faction benefits and penalties based on reputation level by faction name
    fn update_faction_benefits_and_penalties_by_name(&mut self, faction_name: &str) {
        if let Some(reputation) = self.faction_reputations.get_mut(faction_name) {
            Self::update_faction_benefits_and_penalties_static(reputation);
        }
    }

    /// Update faction benefits and penalties based on reputation level
    fn update_faction_benefits_and_penalties_static(reputation: &mut FactionReputation) {
        reputation.benefits.clear();
        reputation.penalties.clear();

        match reputation.reputation_level {
            ReputationLevel::Revered => {
                reputation.benefits = vec![
                    FactionBenefit::ExclusiveQuests,
                    FactionBenefit::TradingBonus(0.25),
                    FactionBenefit::SkillExperienceBonus("Charisma".to_string(), 0.3),
                    FactionBenefit::SpecialServices("Elite Training".to_string()),
                ];
            },
            ReputationLevel::Exalted => {
                reputation.benefits = vec![
                    FactionBenefit::ExclusiveQuests,
                    FactionBenefit::TradingBonus(0.15),
                    FactionBenefit::SkillExperienceBonus("Charisma".to_string(), 0.2),
                ];
            },
            ReputationLevel::Honored => {
                reputation.benefits = vec![
                    FactionBenefit::TradingBonus(0.1),
                    FactionBenefit::SkillExperienceBonus("Charisma".to_string(), 0.1),
                ];
            },
            ReputationLevel::Hostile => {
                reputation.penalties = vec![
                    FactionPenalty::TradingPenalty(0.25),
                    FactionPenalty::QuestRestriction("Faction".to_string()),
                ];
            },
            ReputationLevel::Hated => {
                reputation.penalties = vec![
                    FactionPenalty::TradingPenalty(0.5),
                    FactionPenalty::HostileNpcs("Faction Guards".to_string()),
                    FactionPenalty::AreaRestriction("Faction Territory".to_string()),
                ];
            },
            ReputationLevel::Nemesis => {
                reputation.penalties = vec![
                    FactionPenalty::TradingPenalty(1.0),
                    FactionPenalty::HostileNpcs("All Faction Members".to_string()),
                    FactionPenalty::AreaRestriction("All Faction Areas".to_string()),
                    FactionPenalty::QuestRestriction("All".to_string()),
                ];
            },
            _ => {} // Neutral levels have no special benefits or penalties
        }
    }

    /// Complete a quest and process rewards
    pub fn complete_quest(&mut self, quest_id: Uuid, completion_quality: QuestCompletionQuality) -> Option<CompletedQuest> {
        let quest = self.active_quests.remove(&quest_id)?;
        
        let mut rewards_earned = quest.rewards.clone();
        
        // Adjust rewards based on completion quality
        match completion_quality {
            QuestCompletionQuality::Perfect => {
                // Bonus rewards for perfect completion
                rewards_earned.push(QuestReward::SkillExperience("Charisma".to_string(), 25.0));
            },
            QuestCompletionQuality::Excellent => {
                // Small bonus
                rewards_earned.push(QuestReward::SkillExperience("Charisma".to_string(), 10.0));
            },
            QuestCompletionQuality::Poor => {
                // Reduced rewards
                rewards_earned = rewards_earned.into_iter().map(|reward| {
                    match reward {
                        QuestReward::SkillExperience(skill, amount) => {
                            QuestReward::SkillExperience(skill, amount * 0.5)
                        },
                        _ => reward,
                    }
                }).collect();
            },
            QuestCompletionQuality::Failed => {
                // No rewards, apply consequences
                rewards_earned.clear();
            },
            _ => {} // Average and Good give normal rewards
        }

        // Process reputation changes
        for rep_change in &quest.reputation_changes {
            self.update_faction_reputation(&rep_change.faction_name, rep_change.amount, &rep_change.reason, Some(quest_id));
        }

        let completed_quest = CompletedQuest {
            quest_id,
            completion_time: Utc::now(),
            completion_quality,
            rewards_earned: rewards_earned.clone(),
            reputation_changes: quest.reputation_changes.clone(),
            consequences: Vec::new(),
        };

        self.completed_quests.push(completed_quest.clone());
        Some(completed_quest)
    }

    /// Get available quests for a player based on their reputation and requirements
    pub fn get_available_quests_for_player(&self, player_skills: &std::collections::HashMap<String, super::being::Skill>) -> Vec<&Quest> {
        self.available_quests.values()
            .filter(|quest| self.player_meets_requirements(quest, player_skills))
            .collect()
    }

    /// Check if player meets quest requirements
    fn player_meets_requirements(&self, quest: &Quest, player_skills: &std::collections::HashMap<String, super::being::Skill>) -> bool {
        for requirement in &quest.requirements {
            match requirement {
                QuestRequirement::SkillLevel(skill_name, min_level) => {
                    if let Some(skill) = player_skills.get(skill_name) {
                        if skill.level < *min_level {
                            return false;
                        }
                    } else {
                        return false;
                    }
                },
                QuestRequirement::FactionReputation(faction_name, min_rep) => {
                    if let Some(faction_rep) = self.faction_reputations.get(faction_name) {
                        if faction_rep.reputation_value < *min_rep {
                            return false;
                        }
                    } else if *min_rep > 0 {
                        return false;
                    }
                },
                // Other requirements can be implemented as needed
                _ => continue,
            }
        }
        true
    }

    /// Generate emergency quests from global events
    pub fn generate_emergency_quests(&mut self, global_event: &GlobalEvent) {
        match &global_event.event_type {
            GlobalEventType::NaturalDisaster(disaster_type) => {
                for area in &global_event.affected_areas {
                    let quest = Quest {
                        id: Uuid::new_v4(),
                        title: format!("Emergency Response: {} in {}", disaster_type, area),
                        description: format!("A {} has struck {}. Immediate aid is needed!", disaster_type, area),
                        quest_type: QuestType::Emergency(EmergencyType::NaturalDisaster(disaster_type.clone())),
                        giver_npc_id: Uuid::new_v4(), // Emergency coordinator NPC
                        giver_faction: Some("Emergency Services".to_string()),
                        objectives: vec![
                            QuestObjective {
                                id: Uuid::new_v4(),
                                description: "Provide emergency aid".to_string(),
                                objective_type: ObjectiveType::VisitLocation(area.clone()),
                                progress: 0,
                                target: 1,
                                is_completed: false,
                                is_optional: false,
                                rewards_on_completion: vec![
                                    QuestReward::SkillExperience("Vitality".to_string(), 100.0),
                                ],
                            }
                        ],
                        rewards: vec![
                            QuestReward::FactionReputation("Emergency Services".to_string(), 100),
                            QuestReward::SkillExperience("Courage".to_string(), 150.0),
                            QuestReward::Title("Disaster Relief Hero".to_string()),
                        ],
                        requirements: Vec::new(),
                        time_limit: global_event.end_time,
                        priority: QuestPriority::Critical,
                        reputation_changes: Vec::new(),
                        generated_by_need: None,
                        created_at: Utc::now(),
                        can_fail: true,
                        failure_consequences: vec![
                            QuestConsequence::AreaDamage(area.clone(), 50),
                        ],
                    };
                    self.available_quests.insert(quest.id, quest);
                }
            },
            _ => {} // Other event types can be implemented
        }
    }
}